generator client {
    provider      = "prisma-client-js"
    output        = "../generated/platform"
    binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL_PLATFORM")
}

// User model
model User {
    id       String   @id @default(cuid())
    email    String   @unique
    name     String?
    password String
    role     UserRole @default(USER)

    projectMemberships ProjectMember[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

// User roles
enum UserRole {
    ADMIN
    USER
}

// Project model
model Project {
    id          String  @id @default(cuid())
    name        String
    description String?

    members   ProjectMember[]
    pipelines Pipeline[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model ProjectMember {
    projectId String
    userId    String
    role      MemberRole

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
    user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@id([projectId, userId])
}

enum MemberRole {
    OWNER
    VIEWER
    EDITOR
}

// Pipeline model for Flink jobs
model Pipeline {
    id          String  @id @default(cuid())
    name        String
    description String?
    config      Json // Stores pipeline configuration
    version     Int     @default(1)
    isActive    Boolean @default(false)

    projectId String
    createdBy String
    editedBy  String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
}

// Kafka topic model for Kafka topics 
model KafkaTopic {
    topicName   String     @id
    description String?
    stage       TopicStage
    dataFormat  DataFormat @default(STRING)
    schema      Schema?    @relation(fields: [schemaId], references: [id])
    schemaId    String?    @db.Uuid
    createdAt   DateTime   @default(now())

    connectors       ConnectorConfig[]
    sourceValidators Validator[]       @relation("SourceTopic")
    targetValidators Validator[]       @relation("TargetTopic")
}

model Schema {
    id         String       @id @default(uuid()) @db.Uuid
    schemaName String
    schemaType SchemaType
    version    String
    format     SchemaFormat @default(JSON)
    schema     Json
    createdAt  DateTime     @default(now())

    topics     KafkaTopic[]
    connectors ConnectorConfig[]
    validators Validator[]
}

model ConnectorConfig {
    id             String        @id @default(uuid())
    connectorName  String        @unique
    connectorType  ConnectorType
    endpointUrl    String
    kafkaTopic     KafkaTopic    @relation(fields: [kafkaTopicName], references: [topicName])
    kafkaTopicName String
    inputSchema    Schema?       @relation(fields: [inputSchemaId], references: [id])
    inputSchemaId  String?       @db.Uuid
    config         Json?
    createdAt      DateTime      @default(now())
    updatedAt      DateTime      @updatedAt
}

model Validator {
    id              String        @id @default(uuid())
    sourceTopic     KafkaTopic    @relation("SourceTopic", fields: [sourceTopicName], references: [topicName])
    sourceTopicName String
    targetTopic     KafkaTopic    @relation("TargetTopic", fields: [targetTopicName], references: [topicName])
    targetTopicName String
    schema          Schema        @relation(fields: [schemaId], references: [id])
    schemaId        String        @db.Uuid
    errorStrategy   ErrorStrategy @default(REDIRECT)
    errorTopic      String?
    createdAt       DateTime      @default(now())
}

enum TopicStage {
    RAW
    VALIDATED
    ANALYTICS
    SYSTEM
}

enum DataFormat {
    STRING
    JSON
    BYTES
    AVRO
    PROTOBUF
}

enum SchemaType {
    INPUT
    OUTPUT
}

enum SchemaFormat {
    JSON
    AVRO
    PROTOBUF
}

enum ConnectorType {
    MQTT
    REST
    INPUT_CONNECTOR
}

enum ErrorStrategy {
    LOG
    DROP
    REDIRECT
}
